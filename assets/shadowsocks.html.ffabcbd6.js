import{_ as d,r as n,o as s,c,a as o,b as e,d as a,e as r}from"./app.6ced1075.js";const i={},p=o("h1",{id:"shadowsocks",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#shadowsocks","aria-hidden":"true"},"#"),e(" Shadowsocks")],-1),l={href:"https://shadowsocks.org",target:"_blank",rel:"noopener noreferrer"},u=r('<h2 id="shadowsocks-inbound" tabindex="-1"><a class="header-anchor" href="#shadowsocks-inbound" aria-hidden="true">#</a> Shadowsocks Inbound</h2><ul><li>Name: <code>shadowsocks</code></li><li>Type: Inbound Protocol</li><li>ID: <code>inbound.shadowsocks</code></li></ul><blockquote><p><code>method</code> : string</p></blockquote><p>Encryption method，one of [supported encryption methods](#Supported Encryption Methods) .</p><blockquote><p><code>password</code>: string</p></blockquote><p>A recognized password for this inbound. Shadowsocks does not mandate the length of the password, but it would be easy to crack a short password, thus a password of 16 characters or more is recommended.</p><blockquote><p><code>networks</code>: &quot;tcp&quot; | &quot;udp&quot; | &quot;tcp,udp&quot;</p></blockquote><p>Enabled network type. For example, when <code>&quot;tcp&quot;</code> is specified, this inbound will only accept TCP traffic. This value is <code>&quot;tcp&quot;</code> by default.</p><blockquote><p><code>packetEncoding</code>: [&quot;None&quot; | &quot;Packet&quot;]</p></blockquote><p>UDP packet encoding method，<code>None</code> by default。</p><p>When this value is <code>None</code> , UDP connections will be split into streams based on their destination (Address and Port-Dependent Mapping)。</p><p>When this value is <code>Packet</code>, UDP connections from a single source connection will be encoded as UDP packet addr connection, which will be restored to its original form by a supported outbound as an Endpoint Independent Mapping UDP connection. This UDP behaviour is also known as FullCone or NAT1.</p><h2 id="shadowsocks-outbound" tabindex="-1"><a class="header-anchor" href="#shadowsocks-outbound" aria-hidden="true">#</a> Shadowsocks Outbound</h2><ul><li>Name: <code>shadowsocks</code></li><li>Type: Outbound Protocol</li><li>ID: <code>outbound.shadowsocks</code></li></ul><blockquote><p><code>address</code>: string</p></blockquote><p>The server address. Both IP and domain name is supported.</p><blockquote><p><code>port</code>: number</p></blockquote><p>The server port number.</p><blockquote><p><code>method</code> : string</p></blockquote><p>Encryption method，one of [supported encryption methods](#Supported Encryption Methods) .</p><blockquote><p><code>password</code>: string</p></blockquote><p>A password recognized by server.</p><h2 id="supported-encryption-methods" tabindex="-1"><a class="header-anchor" href="#supported-encryption-methods" aria-hidden="true">#</a> Supported Encryption Methods</h2><ul><li><code>&quot;AES_256_GCM&quot;</code></li><li><code>&quot;AES_128_GCM&quot;</code></li><li><code>&quot;CHACHA20_POLY1305&quot;</code></li><li><code>&quot;NONE&quot;</code></li></ul><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>In &quot;NONE&quot; unencrypted and unauthenticated mode, the server will not try to validate the password.</p><p>This is typically used when authentication is already completed by the transport layer, like enabling TLS encryption and WebSocket transport with a long and unpredictable path.</p></div>',25);function h(b,k){const t=n("ExternalLinkIcon");return s(),c("div",null,[p,o("p",null,[o("a",l,[e("Shadowsocks"),a(t)]),e(" Protocol，mostly compatible with other implementations。")]),u])}const q=d(i,[["render",h],["__file","shadowsocks.html.vue"]]);export{q as default};
